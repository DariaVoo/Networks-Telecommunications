Проект можно разбить на 3 части:
1. Ассемблер - программа которая скомпилирует чемпионов и переведет их с языка ассемблера в байт-код, который интерпретируется виртуальной машиной

2. Виртуальная машина - это арена, где сражаются чемпионы. Должна одновременно выполнять несколько процессов.

3. Чемпион. Особо сильный не нужен. Программа на АСМ

4. Исполняемые файлы должны называться asm и corewar

5. Чемпион должен называться эпически

6. Мэйк должен компилировать либу, затем корвар

7. Разрешены следующие функции:
◦ open
◦ read
◦ lseek
◦ write
◦ close
◦ malloc
◦ realloc
◦ free
◦ perror
◦ strerror
◦ exit


|==|==| Виртуальная машина |==|==|

*******************
В каждом процессе будут доступны следующие эксклюзивные элементы:
REG_NUMBER регистров, каждый из которых имеет размер REG_SIZE октетов. Регистр - это небольшой «ящик» памяти, содержащий только одно значение. На реальной машине это внутреннее устройство процессора и, как следствие, очень БЫСТРЫЙ доступ.
PC («Program counter»). Это специальный регистр, который содержит в памяти виртуальной машины адрес следующего набора инструкций для кодирования и выполнения. Очень полезно выяснить, где мы находимся в процессе выполнения, давая нам советы о том, когда записывать что-то в память ...
Флаг с именем carry, если последняя операция прошла успешно. Только определенные операции могут изменить carry.

*******************
Номер игрока генерируется машиной или указывается при запуске и передается чемпионам через регистр r1 их первого процесса при запуске. Все остальные регистры имеют 0, кроме PC.

*******************
Чемпионы заряжаются в памяти, поэтому они могут равномерно распределить свои точки входа. ???????? F**K

*******************
Виртуальная машина создаст пространство памяти, предназначенное для сражений игроков, затем загрузит каждого чемпиона и связанные с ним процессы и выполнит их последовательно, пока они не умрут.

*******************
Каждые циклы CYCLE_TO_DIE машина должна удостовериться, что каждый процесс выполнил хотя бы один рабочий цикл с момента последней проверки. Процесс, не подчиняющийся этому правилу, будет немедленно уничтожен виртуальной пенной летучей мышью (бонус за звуковой эффект!)

*******************
Если во время одной из этих проверок мы заметим, что с момента последней проверки было хотя бы одно выполнение NBR_LIVE в реальном времени, мы уменьшим CYCLE_TO_DIE единиц CYCLE_DELTA.

*******************
Игра окончена, когда все процессы мертвы.

*******************
Победителем становится последний игрок, о котором сообщают, что он жив. Затем автомат покажет «Player X (champion_name) won», где X - номер игрока, а champion_name - его имя.
Например: “Player 2 (rainbowdash) won”.

*******************
Для каждого допустимого выполнения live инструкции машина должна отображать:
“A process shows that player X (champion_name) is alive”

*******************
Память круговая и состоит из MEM_SIZE октетов.

*******************
В случае ошибки вы должны отобразить соответствующее сообщение об ошибке в стандартном выводе ошибок.

*******************
Если CYCLE_TO_DIE не уменьшилось с момента MAX_CHECKS проверок, уменьшите его.

*******************
> ./corewar [-dump nbr_cycles] [[-n number] champion1.cor] ...

*******************
-dump nbr_cycles
в конце nbr_cycles выполнений выгрузить память на стандартный вывод и выйти из игры. Память должна быть выгружена в шестнадцатеричном формате по 32 октета на строку.

*******************
-n
устанавливает номер следующего игрока. Если его нет, игрок получит следующий доступный номер в порядке следования параметров. У последнего игрока будет первый процесс в порядке выполнения.

*******************
Количество чемпионов не может превышать CHAMP_MAX_SIZE, иначе это ошибка.

|==|==| Ассемблер |==|==|

*******************
Ваша виртуальная машина выполнит машинный код (или «байт-код»), который будет сгенерирован вашим ассемблером. Ассемблер (программа) получит файл, написанный на ассемблере, в качестве аргумента и сгенерирует чемпиона, который будет понят виртуальной машиной.

*******************
> ./asm mychampion.s

*******************
Он будет читать обработанный код сборки из файла .s, указанного в качестве аргумента, и записывать полученный байт-код в файл с таким же именем, как и аргумент, заменяя расширение .s на .cor

*******************
В случае ошибки вам нужно будет отобразить соответствующее сообщение в стандартном выводе ошибок, и не создавать файл .cor

*******************
Ассемблер состоит из одной инструкции в строке.

MOVE TO ANOTHER SECTION
*******************
Инструкция состоит из трех элементов: метки (необязательно), состоящей из цепочки символов из LABEL_CHARS, за которыми следует LABEL_CHAR; код операции; и его параметры, разделенные SEPARATOR_CHAR. Параметр может быть трех разных типов:
◦ Ргистр: (r1 <–> rx с x = REG_NUMBER)
◦ Прямой: символ DIRECT_CHAR, за которым следует числовое значение или метка (перед которой стоит LABEL_CHAR), которая представляет прямое значение.
◦ Косвенный: значение или метка (перед которой стоит LABEL_CHAR), которая представляет значение, расположенное по адресу параметра, относительно PC текущего процесса.

*******************
Метка не может иметь инструкции после нее или быть помещена в строку перед инструкцией, на которую она отвечает. ??????? A label can have no instruction following it or be placed on a line before the instruction it responds to.

*******************
Символ COMMENT_CHAR начинает комментарий.

*******************
У чемпиона также будет имя и описание, которые должны быть в строке после маркеров NAME_CMD_STRING и COMMENT_CMD_STRING.

*******************
Все адреса относятся к PC и IDX_MOD, за исключением lld, lldi и lfork.

*******************
Количество циклов для каждой инструкции, их мнемонические представления, связанное количество и возможные типы аргументов описаны в массиве op_tab, объявленном в op.c. Циклы всегда расходуются.

*******************
Все остальные коды не имеют другого действия, кроме как перейти к следующему и потерять цикл.

*******************
lfork: означает long-fork, чтобы иметь возможность вилкой упираться в соломинку с расстояния 15 метров, точно так же, как с его кодом операции. То же, что и fork без модуля в адресе.

*******************
sti: Opcode 11. Возьмите регистр, и два индекса (потенциально регистры) добавляют два индекса и используют этот результат в качестве адреса, куда будет скопировано значение первого параметра.

*******************
fork: нет байта кодирования аргумента, взять индекс, код операции 0x0c. Создайте новый процесс, который унаследует различные состояния своего отца, за исключением своего PC, который будет помещен в (PC + (1-й параметр% IDX_MOD))

*******************
lld: означает long-load, поэтому очевидно, что это код операции 13. Он такой же, как ld, но без% IDX_MOD. Измените carry.

*******************
ld: Возьмите случайный аргумент и регистр. Загрузите значение первого аргумента в регистр. Его код операции 10 в двоичном формате, и он изменит carry

*******************
add: Opcode 4. Возьмите три регистра, добавьте первые два и поместите результат в третий, прямо перед изменением carry.

*******************
zjmp: никогда не было, не было и никогда не будет байта кодирования аргумента за этой операцией, где код операции равен 9. Он получит индекс и перейдет к этому адресу, если carry равен 1.

*******************
sub: То же, что и add, но с кодом операции est 0b101, и использует вычитание

*******************
ldi: ldi, ldi, судя по названию, не подразумевает купания в каштановом креме, даже если его код 0x0a. Вместо этого он будет использовать 2 индекса и 1 регистр, добавляя первые два, рассматривая это как адрес, считывая значение размера регистра и помещая его в третий.

*******************
or: Эта операция представляет собой побитовое ИЛИ в том же духе и принципе, что и and, ее код операции, очевидно, равен 7.

*******************
st: возьмите регистр и регистр или "косвенный" и сохраните значение регистра в качестве второго аргумента. Его код операции 0x03. Например, st r1, 42 сохранит значение r1 по адресу (PC + (42% IDX_MOD))

*******************
aff: код операции 10 в шестнадцатеричном формате. Есть байт кодирования аргумента, даже если это немного глупо, потому что есть только 1 аргумент, который является регистром, который является регистром, и его содержимое интерпретируется значением ASCII символа для отображения в стандартном выводе. Код построен по модулю 256.

*******************
live: инструкция, позволяющая процессу оставаться в живых. Он также может записать, что игрок, номер которого является аргументом, действительно жив. Байт кодирования аргумента, код операции 0x01. О, и его единственный аргумент занимает 4 байта.

*******************
xor: действует как и с исключающим ИЛИ. Как вы уже догадались, его код операции в восьмеричном формате равен 10.

*******************
lldi: код операции 0x0e. То же, что и ldi, но не применяется к адресам по модулю. Однако это изменит carry.

*******************
and: примените & (побитовое И) к первым двум аргументам и сохраните результат в регистре, который является третьим аргументом. Код операции 0x06. Изменяет carry.


|==|==| Кодирование |==|==|

Каждая инструкция кодируется:
Кодом инструкции (вы найдете его в op_tab).
Байт кодирования аргумента, если это необходимо. Выполняется в соответствии со следующими примерами:
◦ r2,23,% 34 дает байт кодирования 0b01111000, следовательно, 0x78
◦ 23,45,% 34 дает байт кодирования 0b11111000, следовательно, 0xF8
◦ r1, r3,34 дает кодовый байт 0b01011100, следовательно, 0x5C
Аргументы, основанные на следующих примерах:
◦ r2,23,% 34 дает ACB 0x78, затем 0x02 0x00 0x17 0x00 0x00 0x00 0x22
◦ 23,45,% 34 дает ACB 0xF8, затем 0x00 0x17 0x00 0x2d 0x00 0x00 0x00 0x22

*******************
Исполняемый файл всегда будет начинаться с заголовка, определенного в op.h типом header_t.

*******************
Виртуальная машина BIG ENDIAN. Спросите у Google, что это значит.

*******************
.name "zork"
.comment "just a basic living prog"
l2: sti r1,\%:live,\%1
and r1,\%0,r1
live: live \%1
zjmp \%:live
# Executable compilation:
#
# 0x0b,0x68,0x01,0x00,0x0f,0x00,0x01
# 0x06,0x64,0x01,0x00,0x00,0x00,0x00,0x01
# 0x01,0x00,0x00,0x00,0x01
# 0x09,0xff,0xfb



|==|==| Чемпион |==|==|

*******************
Чемпион преследует три основные цели: убедиться, что его игрок считается “alive”, понять смысл жизни и уничтожить своих противников.

*******************
Чтобы ваш игрок был квалифицирован как «живой», ваш чемпион должен удостовериться, что с его номером было достигнуто какое-то количество жизней. Если один из процессов работает с номером другого игрока ... ну не повезло, но, по крайней мере, другой игрок будет счастлив. Если процесс другого игрока забивает ваш номер, вы уполномочен высмеивать его, и вы можете нажиться на его ошибке, оскорбляя его семью в двоичном коде.

*******************
Все и абсолютно ВСЕ инструкции полезны. Все реакции машины, описанные далее в главе, посвященной языку, могут быть использованы для того, чтобы дать жизнь вашему чемпиону и дать ему возможность выиграть приз в размере семнадцати евро и пятидесяти трех центов в чемпионате. Да, даже инструкция aff пригодится, чтобы посмеяться над бесполезностью ваших оппонентов.

*******************
Во время защиты ваш чемпион будет оцениваться по его способности пережить несколько основных испытаний, таких как победа над чемпионом с IQ банана, умение съесть яблочный пирог моей бабушки или рисование цветов в капучино.

*******************
Предполагается, что виртуальная машина имитирует совершенно параллельную машину.

*******************
Однако для целей реализации мы будем предполагать, что каждая инструкция будет выполняться (полностью) в конце своего последнего цикла и ждать всю свою продолжительность.
Команды, заканчивающиеся в том же цикле, будут выполняться в порядке убывания количества процессов.

*******************
Да, первым играет последний (младший) чемпион.

*******************
Этот чемпионат - отдельный проект, все, что вам нужно сделать, это представить чемпиона (не обязательно того же самого, что и для вашей Corewar, по очевидным стратегическим и секретным причинам ...). Он будет запущен на нашей собственной виртуальной машине, поэтому конфигурация будет такой, которую вы опишете в своем файле op.h, который будет прикреплен. Будьте осторожны, файлы op.c и op.h будут приведены в качестве примера, и вам, безусловно, нужно будет изменить их. Вполне возможно, что они не подействуют, поскольку мы могли принять бутылку с водой за бутылку белого уксуса.